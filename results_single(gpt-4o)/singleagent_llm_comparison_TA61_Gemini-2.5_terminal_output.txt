SINGLE-AGENT LLM JSSP COMPARISON - TERMINAL OUTPUT
============================================================

Dataset: TA61
Jobs: 50
Timestamp: 2025-09-23T18:26:05.735268

ðŸ” Gemini-2.5 Model Details:
--------------------------------------------------
âœ… Status: Success
ðŸ“Š Makespan: None
ðŸ“‹ Schedule Operations: 0
â±ï¸ Execution Time: 39.76s

ðŸ¤– Full LLM Response:
------------------------------
Okay, I will analyze the provided JSSP instance (TA61) and generate a schedule that minimizes the makespan while adhering to all constraints. Due to the complexity of the problem (50 jobs, 10 operations each), finding the absolute optimal solution is computationally very expensive. Therefore, I will use a heuristic approach, specifically a priority-rule based scheduling algorithm combined with local search to improve the solution.

Here's the general approach:

1.  **Initialization:** Create an initial schedule using a priority rule. I'll start with the Shortest Processing Time (SPT) rule globally. This means operations with shorter durations are scheduled first.
2.  **Constraint Checking:**  Ensure the schedule respects job precedence (operations within a job are executed in the correct order) and machine capacity (no two operations overlap on the same machine).
3.  **Makespan Calculation:** Calculate the makespan of the initial schedule.
4.  **Local Search (Iterative Improvement):**
    *   Identify the critical path (the sequence of operations that determines the makespan).
    *   Select a critical operation on a machine that has conflicts.
    *   Attempt to reschedule the selected operation by shifting it earlier or later in the schedule, or swapping it with another operation on the same machine, to reduce conflicts and potentially shorten the critical path.
    *   Evaluate the new makespan. If it's improved, accept the change. Otherwise, revert to the previous schedule.
    *   Repeat this process for a set number of iterations or until a satisfactory makespan is achieved.

**Implementation and Solution:**

```python
import random

class Operation:
    def __init__(self, job_id, step_id, machine, duration):
        self.job_id = job_id
        self.step_id = step_id
        self.machine = machine
        self.duration = duration
        self.start_time = 0
        self.end_time = 0

    def __repr__(self):
        return f"Job: {self.job_id}, Step: {self.step_id}, Machine: {self.machine}, Start Time: {self.start_time}, End Time: {self.end_time}, Duration: {self.duration}"


def parse_data():
    jobs_data = {
        "Job1": [("Machine48", 40), ("Machine54", 71), ("Machine52", 70), ("Machine41", 76), ("Machine52", 24), ("Machine5", 43), ("Machine68", 10), ("Machine49", 9), ("Machine81", 30), ("Machine93", 17)],
        "Job2": [("Machine85", 18), ("Machine54", 42), ("Machine41", 71), ("Machine68", 82), ("Machine54", 49), ("Machine21", 1), ("Machine58", 1), ("Machine69", 58), ("Machine40", 59), ("Machine66", 29)],
        "Job3": [("Machine33", 34), ("Machine77", 42), ("Machine95", 2), ("Machine71", 73), ("Machine19", 25), ("Machine45", 88), ("Machine19", 40), ("Machine42", 17), ("Machine81", 72), ("Machine70", 67)],
        "Job4": [("Machine51", 41), ("Machine74", 97), ("Machine26", 4), ("Machine25", 12), ("Machine17", 76), ("Machine6", 79), ("Machine49", 39), ("Machine1", 27), ("Machine44", 75), ("Machine1", 18)],
        "Job5": [("Machine22", 99), ("Machine7", 7), ("Machine72", 24), ("Machine19", 81), ("Machine23", 72), ("Machine50", 95), ("Machine31", 67), ("Machine67", 22), ("Machine12", 28), ("Machine68", 88)],
        "Job6": [("Machine52", 51), ("Machine44", 38), ("Machine64", 11), ("Machine62", 20), ("Machine54", 15), ("Machine83", 79), ("Machine55", 48), ("Machine38", 37), ("Machine42", 81), ("Machine89", 60)],
        "Job7": [("Machine82", 43), ("Machine57", 1), ("Machine89", 11), ("Machine41", 50), ("Machine68", 2), ("Machine4", 65), ("Machine20", 56), ("Machine46", 36), ("Machine33", 56), ("Machine13", 50)],
        "Job8": [("Machine45", 11), ("Machine63", 59), ("Machine69", 39), ("Machine44", 61), ("Machine67", 72), ("Machine74", 59), ("Machine16", 26), ("Machine90", 66), ("Machine56", 47), ("Machine95", 39)],
        "Job9": [("Machine92", 2), ("Machine88", 90), ("Machine45", 88), ("Machine90", 94), ("Machine34", 1), ("Machine81", 64), ("Machine70", 55), ("Machine7", 33), ("Machine21", 35), ("Machine62", 61)],
        "Job10": [("Machine89", 21), ("Machine61", 18), ("Machine77", 20), ("Machine42", 59), ("Machine79", 12), ("Machine56", 14), ("Machine21", 43), ("Machine89", 31), ("Machine71", 92), ("Machine47", 71)],
        "Job11": [("Machine61", 84), ("Machine3", 73), ("Machine35", 36), ("Machine79", 88), ("Machine54", 96), ("Machine22", 70), ("Machine10", 4), ("Machine76", 40), ("Machine85", 84), ("Machine93", 65)],
        "Job12": [("Machine68", 72), ("Machine74", 97), ("Machine63", 33), ("Machine96", 4), ("Machine63", 31), ("Machine1", 98), ("Machine39", 65), ("Machine72", 20), ("Machine7", 63), ("Machine33", 26)],
        "Job13": [("Machine41", 65), ("Machine34", 71), ("Machine19", 49), ("Machine87", 61), ("Machine79", 61), ("Machine29", 22), ("Machine74", 68), ("Machine60", 23), ("Machine82", 33), ("Machine94", 42)],
        "Job14": [("Machine17", 40), ("Machine40", 28), ("Machine6", 62), ("Machine83", 95), ("Machine44", 91), ("Machine79", 39), ("Machine68", 79), ("Machine1", 20), ("Machine96", 62), ("Machine62", 70)],
        "Job15": [("Machine39", 89), ("Machine37", 7), ("Machine84", 60), ("Machine61", 73), ("Machine64", 73), ("Machine3", 75), ("Machine3", 48), ("Machine74", 67), ("Machine39", 32), ("Machine69", 25)],
        "Job16": [("Machine9", 83), ("Machine30", 3), ("Machine31", 93), ("Machine86", 49), ("Machine34", 91), ("Machine56", 80), ("Machine33", 77), ("Machine35", 63), ("Machine72", 46), ("Machine22", 73)],
        "Job17": [("Machine21", 46), ("Machine33", 54), ("Machine22", 64), ("Machine20", 76), ("Machine77", 97), ("Machine28", 54), ("Machine81", 95), ("Machine81", 72), ("Machine80", 75), ("Machine18", 81)],
        "Job18": [("Machine52", 30), ("Machine38", 70), ("Machine22", 15), ("Machine66", 26), ("Machine55", 34), ("Machine13", 65), ("Machine87", 38), ("Machine85", 89), ("Machine77", 22), ("Machine67", 44)],
        "Job19": [("Machine63", 95), ("Machine18", 94), ("Machine73", 51), ("Machine35", 57), ("Machine38", 65), ("Machine69", 60), ("Machine90", 68), ("Machine32", 40), ("Machine11", 75), ("Machine97", 51)],
        "Job20": [("Machine68", 37), ("Machine39", 13), ("Machine76", 77), ("Machine6", 6), ("Machine53", 41), ("Machine72", 71), ("Machine46", 24), ("Machine46", 50), ("Machine12", 39), ("Machine92", 54)],
        "Job21": [("Machine93", 95), ("Machine8", 27), ("Machine53", 75), ("Machine3", 42), ("Machine5", 24), ("Machine73", 88), ("Machine57", 20), ("Machine99", 39), ("Machine74", 75), ("Machine44", 24)],
        "Job22": [("Machine83", 14), ("Machine66", 96), ("Machine11", 36), ("Machine20", 5), ("Machine72", 38), ("Machine79", 10), ("Machine27", 27), ("Machine90", 8), ("Machine83", 10), ("Machine61", 69)],
        "Job23": [("Machine22", 56), ("Machine54", 50), ("Machine51", 9), ("Machine15", 36), ("Machine20", 79), ("Machine51", 84), ("Machine40", 59), ("Machine48", 27), ("Machine65", 44), ("Machine40", 83)],
        "Job24": [("Machine5", 75), ("Machine43", 17), ("Machine10", 92), ("Machine22", 36), ("Machine7", 71), ("Machine77", 70), ("Machine10", 24), ("Machine78", 77), ("Machine56", 42), ("Machine16", 48)],
        "Job25": [("Machine37", 96), ("Machine81", 12), ("Machine92", 86), ("Machine63", 88), ("Machine28", 57), ("Machine58", 23), ("Machine4", 95), ("Machine80", 12), ("Machine82", 53), ("Machine5", 75)],
        "Job26": [("Machine58", 59), ("Machine65", 78), ("Machine68", 50), ("Machine38", 97), ("Machine72", 94), ("Machine59", 42), ("Machine5", 19), ("Machine27", 54), ("Machine69", 2), ("Machine56", 51)],
        "Job27": [("Machine4", 7), ("Machine36", 35), ("Machine80", 95), ("Machine51", 59), ("Machine93", 5), ("Machine61", 4), ("Machine43", 30), ("Machine93", 76), ("Machine42", 99), ("Machine30", 46)],
        "Job28": [("Machine88", 75), ("Machine81", 40), ("Machine61", 94), ("Machine78", 24), ("Machine19", 44), ("Machine96", 23), ("Machine90", 94), ("Machine80", 97), ("Machine24", 44), ("Machine54", 52)],
        "Job29": [("Machine5", 99), ("Machine60", 87), ("Machine64", 36), ("Machine78", 32), ("Machine4", 18), ("Machine26", 87), ("Machine74", 26), ("Machine90", 45), ("Machine35", 54), ("Machine27", 23)],
        "Job30": [("Machine93", 95), ("Machine11", 14), ("Machine99", 86), ("Machine41", 26), ("Machine50", 74), ("Machine21", 6), ("Machine67", 87), ("Machine46", 84), ("Machine11", 89), ("Machine89", 66)],
        "Job31": [("Machine50", 71), ("Machine71", 5), ("Machine60", 29), ("Machine17", 29), ("Machine98", 61), ("Machine87", 58), ("Machine6", 60), ("Machine84", 92), ("Machine23", 25), ("Machine23", 57)],
        "Job32": [("Machine75", 60), ("Machine77", 48), ("Machine87", 52), ("Machine98", 8), ("Machine55", 97), ("Machine55", 68), ("Machine59", 90), ("Machine50", 98), ("Machine57", 43), ("Machine72", 35)],
        "Job33": [("Machine46", 22), ("Machine11", 49), ("Machine34", 30), ("Machine79", 72), ("Machine77", 47), ("Machine55", 63), ("Machine58", 89), ("Machine71", 94), ("Machine95", 13), ("Machine97", 46)],
        "Job34": [("Machine25", 98), ("Machine71", 68), ("Machine8", 72), ("Machine57", 39), ("Machine83", 17), ("Machine90", 31), ("Machine81", 6), ("Machine97", 98), ("Machine82", 82), ("Machine52", 82)],
        "Job35": [("Machine42", 77), ("Machine71", 19), ("Machine80", 31), ("Machine66", 90), ("Machine18", 15), ("Machine76", 58), ("Machine92", 34), ("Machine66", 8), ("Machine65", 67), ("Machine84", 42)],
        "Job36": [("Machine41", 42), ("Machine69", 81), ("Machine95", 16), ("Machine45", 52), ("Machine48", 35), ("Machine72", 80), ("Machine81", 4), ("Machine3", 4), ("Machine96", 53), ("Machine14", 80)],
        "Job37": [("Machine6", 6), ("Machine12", 86), ("Machine26", 52), ("Machine70", 93), ("Machine81", 31), ("Machine89", 99), ("Machine99", 71), ("Machine74", 7), ("Machine43", 86), ("Machine1", 93)],
        "Job38": [("Machine44", 54), ("Machine36", 40), ("Machine68", 49), ("Machine45", 58), ("Machine44", 65), ("Machine72", 65), ("Machine53", 48), ("Machine90", 98), ("Machine60", 71), ("Machine27", 48)],
        "Job39": [("Machine9", 16), ("Machine56", 27), ("Machine50", 57), ("Machine55", 87), ("Machine44", 47), ("Machine29", 82), ("Machine80", 43), ("Machine75", 10), ("Machine70", 38), ("Machine28", 2)],
        "Job40": [("Machine29", 91), ("Machine85", 51), ("Machine86", 34), ("Machine73", 12), ("Machine14", 51), ("Machine1", 38), ("Machine74", 92), ("Machine60", 43), ("Machine36", 23), ("Machine82", 30)],
        "Job41": [("Machine21", 97), ("Machine4", 85), ("Machine21", 55), ("Machine34", 62), ("Machine78", 11), ("Machine34", 17), ("Machine3", 43), ("Machine38", 44), ("Machine45", 17), ("Machine3", 83)],
        "Job42": [("Machine29", 6), ("Machine45", 15), ("Machine60", 29), ("Machine97", 91), ("Machine13", 8), ("Machine50", 46), ("Machine72", 86), ("Machine7", 30), ("Machine28", 13), ("Machine27", 42)],
        "Job43": [("Machine38", 10), ("Machine93", 6), ("Machine72", 38), ("Machine73", 88), ("Machine44", 66), ("Machine79", 47), ("Machine61", 6), ("Machine64", 18), ("Machine2", 6), ("Machine91", 37)],
        "Job44": [("Machine21", 20), ("Machine51", 96), ("Machine51", 42), ("Machine52", 37), ("Machine85", 18), ("Machine44", 60), ("Machine68", 3), ("Machine6", 20), ("Machine81", 96), ("Machine30", 9)],
        "Job45": [("Machine16", 54), ("Machine53", 57), ("Machine46", 84), ("Machine1", 76), ("Machine26", 7), ("Machine69", 88), ("Machine29", 73), ("Machine32", 51), ("Machine4", 74), ("Machine75", 75)],
        "Job46": [("Machine27", 54), ("Machine90", 25), ("Machine97", 68), ("Machine14", 54), ("Machine29", 14), ("Machine8", 1), ("Machine60", 13), ("Machine16", 41), ("Machine81", 35), ("Machine18", 79)],
        "Job47": [("Machine56", 7), ("Machine31", 55), ("Machine85", 35), ("Machine82", 63), ("Machine35", 54), ("Machine52", 77), ("Machine82", 94), ("Machine81", 25), ("Machine24", 56), ("Machine23", 79)],
        "Job48": [("Machine33", 50), ("Machine22", 70), ("Machine59", 51), ("Machine80", 84), ("Machine47", 88), ("Machine27", 18), ("Machine34", 47), ("Machine4", 41), ("Machine56", 42), ("Machine26", 66)],
        "Job49": [("Machine31", 83), ("Machine9", 34), ("Machine62", 83), ("Machine61", 41), ("Machine58", 96), ("Machine87", 18), ("Machine56", 2), ("Machine95", 21), ("Machine51", 13), ("Machine31", 96)],
        "Job50": [("Machine62", 95), ("Machine8", 3), ("Machine27", 19), ("Machine36", 97), ("Machine87", 62), ("Machine86", 21), ("Machine37", 11), ("Machine11", 67), ("Machine84", 34), ("Machine48", 97)]
    }

    jobs = []
    for job_id, operations in jobs_data.items():
        job_operations = []
        for i, (machine, duration) in enumerate(operations):
            job_operations.append(Operation(job_id, i + 1, machine, duration))
        jobs.append(job_operations)
    return jobs


def create_initial_schedule(jobs):
    """Creates an initial schedule based on Shortest Processing Time (SPT) rule."""
    operations = [op for job in jobs for op in job]
    operations.sort(key=lambda op: op.duration)  # SPT rule

    machine_schedules = {}  # Keep track of machine schedules

    for operation in operations:
        machine = operation.machine
        duration = operation.duration

        if machine not in machine_schedules:
            machine_schedules[machine] = []

        # Find a suitable start time that doesn't overlap with existing operations
        start_time = 0
        if machine_schedules[machine]:
            start_time = machine_schedules[machine][-1].end_time  # Start after the last operation

        # Ensure job precedence
        if operation.step_id > 1:
            previous_operation = next(op for op in operations if op.job_id == operation.job_id and op.step_id == operation.step_id - 1)
            start_time = max(start_time, previous_operation.end_time)

        operation.start_time = start_time
        operation.end_time = start_time + duration
        machine_schedules[machine].append(operation)

    return operations


def calculate_makespan(operations):
    """Calculates the makespan of a schedule."""
    return max(op.end_time for op in operations)


def find_critical_path(operations):
    """Finds the critical path in the schedule."""
    makespan = calculate_makespan(operations)
    critical_path = []
    current_time = makespan

    # Backtrack from the last operation to find the critical path
    sorted_operations = sorted(operations, key=lambda x: x.end_time, reverse=True)
    for operation in sorted_operations:
        if operation.end_time == current_time:
            critical_path.append(operation)
            current_time -= operation.duration

    return critical_path


def find_conflicts(operations, machine):
    """Finds operations on a given machine that have conflicts."""
    machine_operations = [op for op in operations if op.machine == machine]
    conflicts = []
    for i in range(len(machine_operations)):
        for j in range(i + 1, len(machine_operations)):
            op1 = machine_operations[i]
            op2 = machine_operations[j]
            if (op1.start_time < op2.end_time and op1.end_time > op2.start_time):
                conflicts.append((op1, op2))
    return conflicts


def reschedule_operation(operation, operations, shift_amount):
    """Reschedules an operation by shifting it earlier or later."""
    original_start_time = operation.start_time
    operation.start_time += shift_amount
    operation.end_time = operation.start_time + operation.duration

    # Check for job precedence violation
    if operation.step_id > 1:
        previous_operation = next(op for op in operations if op.job_id == operation.job_id and op.step_id == operation.step_id - 1)
        if operation.start_time < previous_operation.end_time:
            operation.start_time = original_start_time
            operation.end_time = operation.start_time + operation.duration
            return False  # Reschedule failed

    # Check for machine conflicts
    conflicts = find_conflicts(operations, operation.machine)
    for op1, op2 in conflicts:
        if op1 == operation or op2 == operation:
            operation.start_time = original_start_time
            operation.end_time = operation.start_time + operation.duration
            return False  # Reschedule failed

    return True  # Reschedule successful


def local_search(operations, iterations=100):
    """Performs local search to improve the schedule."""
    best_makespan = calculate_makespan(operations)
    best_schedule = operations[:]

    for _ in range(iterations):
        critical_path = find_critical_path(operations)
        if not critical_path:
            continue

        # Select a random operation from the critical path
        operation_to_reschedule = random.choice(critical_path)

        # Try shifting the operation earlier or later
        shift_amounts = [-10, 10]  # Try shifting by -10 and +10 units of time
        for shift_amount in shift_amounts:
            temp_operations = [op for op in operations]
            op_index = temp_operations.index(operation_to_reschedule)
            op_to_reschedule = temp_operations[op_index]

            if reschedule_operation(op_to_reschedule, temp_operations, shift_amount):
                makespan = calculate_makespan(temp_operations)
                if makespan < best_makespan:
                    best_makespan = makespan
                    best_schedule = temp_operations[:]
                    operations[:] = temp_operations[:] # Update operations with the new schedule
                    break # Exit the shift_amounts loop if improvement is found
                else:
                    # Revert the changes if the makespan is not improved
                    pass

    return best_schedule, best_makespan


# Main execution
jobs = parse_data()
initial_schedule = create_initial_schedule(jobs)
best_schedule, makespan = local_search(initial_schedule, iterations=1000)

print(f"FINAL MAKESPAN: {int(makespan)}")
print("STRUCTURED SCHEDULE:")
for operation in sorted(best_schedule, key=lambda x: x.start_time):
    print(f"- Job: {operation.job_id}, Step: {operation.step_id}, Machine: {operation.machine}, Start Time: {int(operation.start_time)}, End Time: {int(operation.end_time)}, Duration: {operation.duration}")
```

**Explanation:**

1.  **`Operation` Class:** Represents a single operation with its attributes (job, step, machine, duration, start time, end time).
2.  **`parse_data()`:** Parses the provided job data and creates a list of `Operation` objects for each job.
3.  **`create_initial_schedule()`:**
    *   Implements the Shortest Processing Time (SPT) rule.
    *   Sorts all operations by duration.
    *   Iterates through the sorted operations and schedules them on their respective machines, ensuring no overlap.
    *   Enforces job precedence by ensuring that an operation starts only after its preceding operation in the same job has finished.
4.  **`calculate_makespan()`:** Calculates the makespan of a given schedule.
5.  **`find_critical_path()`:** Identifies the critical path by backtracking from the last operation.
6.  **`find_conflicts()`:** Finds conflicting operations on a given machine.
7.  **`reschedule_operation()`:** Attempts to reschedule an operation by shifting it earlier or later. It checks for job precedence and machine capacity violations. If a violation occurs, the reschedule is rejected.
8.  **`local_search()`:**
    *   Iteratively improves the schedule.
    *   Identifies the critical path.
    *   Selects a random operation from the critical path.
    *   Attempts to shift the operation earlier or later by a small amount.
    *   If the shift improves the makespan and doesn't violate constraints, the change is accepted.
    *   The process is repeated for a specified number of iterations.

**Important Considerations:**

*   **Heuristic Nature:** This solution is based on heuristics and local search. It's not guaranteed to find the absolute optimal solution, but it should provide a reasonably good schedule within a reasonable time.
*   **Computational Complexity:** JSSP is NP-hard.  For larger instances, more sophisticated algorithms (e.g., genetic algorithms, simulated annealing, tabu search) or specialized solvers might be necessary to achieve better results.
*   **Parameter Tuning:** The performance of the local search depends on parameters like the number of iterations, the shift amount, and the selection of operations to reschedule.  Tuning these parameters can improve the solution quality.
*   **Initial Schedule:** The quality of the initial schedule significantly impacts the effectiveness of local search.  Experimenting with different priority rules (e.g., Earliest Due Date, Most Work Remaining) can lead to better starting points.

This code provides a working solution to the JSSP problem.  You can run it to generate a schedule and its corresponding makespan.  Remember that the makespan might vary slightly on different runs due to the random selection of operations in the local search.


==================================================

