\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{array}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{listings}
\usepackage{xcolor}

\geometry{margin=1in}

\title{Prompt Setup and Input/Output Examples for Multi-Agent JSSP Frameworks}
\author{}
\date{}

% Define colors for code highlighting
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\maketitle

\section{Introduction}

This document presents the prompt setup and input/output examples for four multi-agent frameworks used in Job Shop Scheduling Problem (JSSP) evaluation: AutoGen, CrewAI, LangGraph, and OpenAI Swarm. Each framework is configured with a 3-agent structure consisting of a Job Scheduler Agent, Machine Coordinator Agent, and Supervisor Agent.

\section{Common JSSP Query Structure}

All frameworks receive the same base JSSP query structure generated by the \texttt{run\_jssp\_framework\_comparison.py} script:

\begin{lstlisting}[language=Python, caption=Base JSSP Query Generation]
def _create_jssp_query(self, dataset_name: str, jobs: List[Dict]) -> str:
    """Create a JSSP query for non-MAPLE frameworks"""
    query = f"""
    Job Shop Scheduling Problem (JSSP) - Dataset: {dataset_name}
    
    Problem Description:
    - Number of jobs: {len(jobs)}
    - Each job has multiple operations that must be performed in sequence
    - Each operation requires a specific machine and has a duration
    - Each machine can only process one operation at a time
    - Goal: Find the minimum makespan (total completion time)
    
    Job Specifications:
    """
    
    for job in jobs:
        query += f"\n{job['name']}:"
        for i, (machine, duration) in enumerate(job['steps']):
            query += f"\n  Step {i+1}: Machine {machine}, Duration {duration}"
    
    query += """
    
    REQUIRED OUTPUT FORMAT:
    You must provide your solution in the following exact format:
    
    1. FINAL MAKESPAN: [integer value]
    2. STRUCTURED SCHEDULE:
       For each operation, provide:
       - Job: [job_name]
       - Step: [step_number]
       - Machine: [machine_name]
       - Start Time: [start_time]
       - End Time: [end_time]
       - Duration: [duration]
    
    Example format:
    FINAL MAKESPAN: 25
    STRUCTURED SCHEDULE:
    - Job: Job1, Step: 1, Machine: Machine0, Start Time: 0, End Time: 3, Duration: 3
    - Job: Job1, Step: 2, Machine: Machine1, Start Time: 3, End Time: 7, Duration: 4
    - Job: Job2, Step: 1, Machine: Machine1, Start Time: 7, End Time: 10, Duration: 3
    
    Please solve this Job Shop Scheduling Problem and provide:
    1. A valid schedule with start and end times for each operation
    2. The minimum makespan (total completion time)
    3. Ensure all constraints are satisfied:
       - Job precedence: operations within a job must be sequential
       - Machine constraints: no overlapping operations on the same machine
    """
    
    return query
\end{lstlisting}

\section{MAPLE Framework}

\subsection{Agent Configuration}

MAPLE uses a dynamic multi-agent structure with individual job agents and a supervisor:

\begin{itemize}
    \item \textbf{Individual Job Agents}: One agent per job (e.g., Job1 Agent, Job2 Agent, etc.) responsible for scheduling their specific job's operations
    \item \textbf{Supervisor Agent}: Coordinates all job agents and finds the minimum makespan solution
\end{itemize}

\subsection{Agent Prompts}

\begin{lstlisting}[caption=MAPLE Agent Prompts]
# Individual Job Agents (e.g., Job1 Agent)
name: "Job1 Agent"
backstory: "Agent for Job1 scheduling."
task_description: "Schedule steps for Job1 on required machines with precedence."
task_expected_output: "Step schedule for Job1 respecting machine and precedence constraints."

# Supervisor Agent
name: "Supervisor Agent"
backstory: "Supervisor agent that coordinates all job schedules to find the minimum makespan solution."
task_description: """Find the minimum makespan schedule for all jobs while strictly following these rules:
1. Each job's steps must be completed in strict order (e.g., Job1's step 2 can only start after step 1 is completed).
2. Each machine can only process one job step at a time (e.g., if MachineA is processing Job1's step 1 from time 0-3, it cannot process any other job steps during that time).

The goal is to minimize the total completion time (makespan) while ensuring all jobs are completed and all constraints are satisfied."""
task_expected_output: "A complete schedule with minimum makespan that satisfies all constraints."
\end{lstlisting}

\subsection{Example Input (rcmax\_20\_15\_5 Dataset)}

\begin{lstlisting}[caption=MAPLE Input Example]
# MAPLE receives the job data directly as structured objects
jobs = [
    {
        'name': 'Job1',
        'steps': [
            ('Machine0', 34), ('Machine1', 38), ('Machine2', 42), 
            ('Machine3', 36), ('Machine4', 40), ('Machine5', 44),
            ('Machine6', 38), ('Machine7', 42), ('Machine8', 46),
            ('Machine9', 40), ('Machine10', 44), ('Machine11', 48),
            ('Machine12', 42), ('Machine13', 46), ('Machine14', 50)
        ]
    },
    {
        'name': 'Job2', 
        'steps': [
            ('Machine1', 41), ('Machine2', 45), ('Machine3', 39),
            # ... continues for all 15 steps
        ]
    },
    # ... continues for all 20 jobs
]

# Task specification for MAPLE
task_spec = {
    'nodes': [
        # Individual job agents
        {'agent': job1_agent, 'dependencies': []},
        {'agent': job2_agent, 'dependencies': []},
        # ... for all 20 jobs
        # Supervisor depends on all job agents
        {'agent': supervisor_agent, 'dependencies': [agent.name for agent in job_agents]}
    ],
    'edges': [],
    'jobs': jobs,
    'disruptions': [],
    'rules': [
        'Each job must perform its steps strictly in order.',
        'Each machine can only handle one operation at a time.',
        'No two operations use the same machine at the same time.'
    ]
}
\end{lstlisting}

\subsection{Example Output}

\begin{lstlisting}[caption=MAPLE Output Example]
# MAPLE generates structured schedule output
schedule = [
    {'job': 'Job1', 'step': 1, 'machine': 'Machine0', 'start': 0, 'end': 34, 'duration': 34},
    {'job': 'Job1', 'step': 2, 'machine': 'Machine1', 'start': 34, 'end': 72, 'duration': 38},
    {'job': 'Job1', 'step': 3, 'machine': 'Machine2', 'start': 72, 'end': 114, 'duration': 42},
    # ... continues for all operations
    
    {'job': 'Job2', 'step': 1, 'machine': 'Machine1', 'start': 72, 'end': 113, 'duration': 41},
    {'job': 'Job2', 'step': 2, 'machine': 'Machine2', 'start': 114, 'end': 159, 'duration': 45},
    # ... continues for all jobs
]

# Final makespan calculation
makespan = max(entry['end'] for entry in schedule)  # e.g., 4334
\end{lstlisting}

\subsection{MAPLE Workflow}

\begin{lstlisting}[caption=MAPLE Execution Workflow]
# Initialize MAPLE with task specification
maple = MAPLE(task_spec)

# Run MAPLE with rollback and validation
maple.run(with_rollback=True, validate=True)

# Extract results from executor context
context = maple.executor.context
supervisor_output = context.get(supervisor_agent.name, {})

# Process supervisor output to get final schedule
if 'schedule' in supervisor_output:
    all_schedules = supervisor_output['schedule']
    makespan = max(entry.get('end', 0) for entry in all_schedules)
    
    # Calculate upper bound and gap
    machine_names = list({entry.get('machine') for entry in all_schedules if 'machine' in entry})
    job_sums = {job['name']: sum(duration for _, duration in job['steps']) for job in jobs}
    machine_sums = {name: 0 for name in machine_names}
    
    for job in jobs:
        for machine, duration in job['steps']:
            machine_sums[machine] += duration
    
    ub = max(max(job_sums.values()), max(machine_sums.values()))
    gap = makespan - ub
\end{lstlisting}

\section{AutoGen Framework}

\subsection{Agent Configuration}

AutoGen uses a 3-agent structure with the following configuration:

\begin{itemize}
    \item \textbf{Job Scheduler Agent}: Analyzes job requirements and creates initial schedules
    \item \textbf{Machine Coordinator Agent}: Coordinates machine usage and resolves conflicts
    \item \textbf{Supervisor Agent}: Final coordination and optimization
\end{itemize}

\subsection{Agent Prompts}

\begin{lstlisting}[caption=AutoGen Agent Prompts]
# Job Scheduler Agent
system_message: "You are a Job Scheduler Agent responsible for analyzing job requirements and creating initial schedules."

# Machine Coordinator Agent  
system_message: "You are a Machine Coordinator Agent responsible for coordinating machine usage and resolving conflicts."

# Supervisor Agent
system_message: "You are a Supervisor Agent responsible for final coordination and optimization."
\end{lstlisting}

\subsection{Example Input (abz07 Dataset)}

\begin{lstlisting}[caption=AutoGen Input Example]
Job Shop Scheduling Problem (JSSP) - Dataset: abz07

Problem Description:
- Number of jobs: 20
- Each job has multiple operations that must be performed in sequence
- Each operation requires a specific machine and has a duration
- Each machine can only process one operation at a time
- Goal: Find the minimum makespan (total completion time)

Job Specifications:

Job1:
  Step 1: Machine Machine2, Duration 24
  Step 2: Machine Machine3, Duration 12
  Step 3: Machine Machine9, Duration 17
  Step 4: Machine Machine4, Duration 27
  Step 5: Machine Machine0, Duration 21
  Step 6: Machine Machine6, Duration 25
  Step 7: Machine Machine8, Duration 27
  Step 8: Machine Machine7, Duration 26
  Step 9: Machine Machine1, Duration 30
  Step 10: Machine Machine5, Duration 31
  Step 11: Machine Machine11, Duration 18
  Step 12: Machine Machine14, Duration 16
  Step 13: Machine Machine13, Duration 39
  Step 14: Machine Machine10, Duration 19
  Step 15: Machine Machine12, Duration 26

[... continues for all 20 jobs ...]

REQUIRED OUTPUT FORMAT:
You must provide your solution in the following exact format:

1. FINAL MAKESPAN: [integer value]
2. STRUCTURED SCHEDULE:
   For each operation, provide:
   - Job: [job_name]
   - Step: [step_number]
   - Machine: [machine_name]
   - Start Time: [start_time]
   - End Time: [end_time]
   - Duration: [duration]
\end{lstlisting}

\subsection{Example Output}

\begin{lstlisting}[caption=AutoGen Output Example]
Job Scheduler Agent Output:
To effectively coordinate machine schedules and ensure no overlapping operations while optimizing machine utilization, follow these steps:

1. **Data Collection**: Gather all necessary information about machine operations, including machine availability, job requirements, start and end times, and priority of tasks.

2. **Job Prioritization**: Prioritize jobs based on deadlines, importance, and resource requirements. This will help in scheduling critical tasks first.

3. **Machine Availability**: List all available machines and their operational capabilities. Ensure that each machine is suitable for the tasks assigned to it.

4. **Conflict Detection**: Check for overlapping schedules where a machine is double-booked. Identify conflicts by examining start and end times of scheduled tasks.

5. **Conflict Resolution**:
   - **Reschedule**: Adjust the timing of conflicting jobs to eliminate overlaps.
   - **Reassign Tasks**: If rescheduling is not feasible, consider moving tasks to different machines that are compatible with the operations.
   - **Prioritize Tasks**: Focus on completing high-priority jobs within their deadlines while adjusting lower-priority tasks as needed.

[... detailed coordination strategy ...]

### Solution for abz07 Dataset

#### FINAL MAKESPAN
The optimized makespan value is determined based on the integration of job scheduling and machine coordination, but due to the complexity of explicitly listing each job's sequence, I'm summarizing the strategy and example timeline as applied heuristics and machine coordination data show:

1. **Makespan**: Calculated based on the complete scheduling and optimization of machine operations. Though not specified in exact final numeric form without further computational analysis directly from the in-depth schedule provided by advanced tools, the methodology indicates a near-optimal alignment according to the processes described.

#### STRUCTURED SCHEDULE:

Here's a structured schedule format for visualization. Key operations are coordinated with attention to machine non-conflict and sequence according to job precedence.

- **Job1**:
  - Step 1: Machine Machine2, Start Time: 0, End Time: 24, Duration: 24
  - Step 2: Machine Machine3, Start Time: 25, End Time: 37, Duration: 12
  - (Further steps continue similarly, coordinated by machine availability)

- **Job2**:
  - Step 1: Machine Machine6, Start Time: 0, End Time: 30, Duration: 30
  - Step 2: Machine Machine3, Start Time: 31, End Time: 46, Duration: 15
  - (Next steps adapted similarly to job requirements and resource availability)

[... continues for all jobs ...]
\end{lstlisting}

\section{CrewAI Framework}

\subsection{Agent Configuration}

CrewAI uses a 3-agent structure with role-based configuration:

\begin{itemize}
    \item \textbf{Job Scheduler Agent}: Role-based agent for job scheduling
    \item \textbf{Machine Coordinator Agent}: Role-based agent for machine coordination  
    \item \textbf{Supervisor Agent}: Role-based supervisor for final coordination
\end{itemize}

\subsection{Agent Prompts}

\begin{lstlisting}[caption=CrewAI Agent Prompts]
# Job Scheduler Agent
role: 'Job Scheduler'
goal: 'Analyze job requirements and create initial schedules for all jobs.'
backstory: 'You are an expert job scheduler responsible for analyzing job requirements and creating initial schedules.'

# Machine Coordinator Agent
role: 'Machine Coordinator'  
goal: 'Coordinate machine usage and resolve conflicts between jobs.'
backstory: 'You are an expert machine coordinator responsible for optimizing machine usage and resolving conflicts.'

# Supervisor Agent
role: 'JSSP Supervisor'
goal: 'Aggregate all job schedules and produce the overall JSSP schedule. Coordinate between all job agents to find the optimal solution.'
backstory: 'You are a supervisor with expertise in Job Shop Scheduling Problems and can coordinate multiple agents to find optimal solutions.'
\end{lstlisting}

\subsection{Example Output}

\begin{lstlisting}[caption=CrewAI Output Example]
Job Scheduler Agent Output:
Action: Calculate optimized makespan and finalize structured schedule based on resolved conflicts and optimal sequencing.

Machine Coordinator Agent Output: No output generated

Supervisor Agent Output: No output generated
\end{lstlisting}

\section{LangGraph Framework}

\subsection{Agent Configuration}

LangGraph uses a 3-agent structure with system prompts:

\begin{itemize}
    \item \textbf{Job Scheduler Agent}: LangGraph workflow agent for job scheduling
    \item \textbf{Machine Coordinator Agent}: LangGraph workflow agent for machine coordination
    \item \textbf{Supervisor Agent}: LangGraph workflow agent for supervision
\end{itemize}

\subsection{Agent Prompts}

\begin{lstlisting}[caption=LangGraph Agent Prompts]
# Job Scheduler Agent
system_prompt: 'You are a Job Scheduler Agent using LangGraph workflow. Analyze job requirements and create initial schedules for all jobs.'

# Machine Coordinator Agent
system_prompt: 'You are a Machine Coordinator Agent using LangGraph workflow. Coordinate machine usage and resolve conflicts between jobs.'

# Supervisor Agent  
system_prompt: 'You are a Supervisor Agent using LangGraph workflow. Aggregate all job schedules and produce the overall JSSP schedule. Coordinate between all job agents to find the optimal solution.'
\end{lstlisting}

\subsection{Example Output}

\begin{lstlisting}[caption=LangGraph Output Example]
Job Scheduler Agent Output:
=== LANGGRAPH REAL AGENTS ===

Job Scheduler Agent: To solve the Job Shop Scheduling Problem (JSSP) for the given dataset (abz07), we need to create a schedule that minimizes the makespan while satisfying all constraints. This involves determining the start and end times for each operation across all jobs, ensuring that no two operations overlap on the same machine and that operations within a job are performed sequentially.

Given the complexity of the problem and the constraints, a heuristic or optimization algorithm such as Genetic Algorithm, Tabu Search, or Simulated Annealing is typically used to find a near-optimal solution. However, due to the constraints of this environment, I will provide a conceptual approach to how this can be achieved, along with a simplified example of a possible schedule.

### Conceptual Approach:
1. **Initialize**: Start with an initial feasible schedule where operations are scheduled sequentially based on job order and machine availability.
2. **Iterate**: Use a heuristic or optimization algorithm to iteratively improve the schedule by exploring different sequences and machine assignments.
3. **Evaluate**: Calculate the makespan for each schedule and keep track of the best (minimum) makespan found.
4. **Constraints**: Ensure that all job precedence and machine constraints are satisfied in each iteration.

### Simplified Example Schedule:
Below is a simplified example of how the schedule might look. Note that this is a conceptual representation and not the actual solution due to the complexity of the problem.

```
FINAL MAKESPAN: 1000
STRUCTURED SCHEDULE:
- Job: Job1, Step: 1, Machine: Machine2, Start Time: 0, End Time: 24, Duration: 24
- Job: Job1, Step: 2, Machine: Machine3, Start Time: 24, End Time: 36, Duration: 12
- Job: Job1, Step: 3, Machine: Machine9, Start Time: 36, End Time: 53, Duration: 17
- Job: Job2, Step: 1, Machine: Machine6, Start Time: 0, End Time: 30, Duration: 30
- Job: Job2, Step: 2, Machine: Machine3, Start Time: 36, End Time: 51, Duration: 15
[... continues for all operations ...]
```
\end{lstlisting}

\section{OpenAI Swarm Framework}

\subsection{Agent Configuration}

OpenAI Swarm uses a 3-agent structure with detailed role specifications:

\begin{itemize}
    \item \textbf{Job Scheduler Agent}: Creates initial schedules considering precedence constraints
    \item \textbf{Machine Coordinator Agent}: Resolves machine conflicts and optimizes utilization
    \item \textbf{Supervisor Agent}: Coordinates all agents and provides final JSSP solution
\end{itemize}

\subsection{Agent Prompts}

\begin{lstlisting}[caption=OpenAI Swarm Agent Prompts]
# Job Scheduler Agent
role: 'Job Scheduler'
goal: 'Create initial schedules for all jobs considering precedence constraints.'
backstory: 'You are a job scheduling agent responsible for creating initial schedules for all jobs in Job Shop Scheduling Problems.'
query: 'Create initial schedules for 20 jobs with their respective steps.

Dataset: abz07
Number of jobs: 20
Number of machines: 15

Job Specifications:
Job1:
  Step 1: Machine Machine2, Duration 24
  Step 2: Machine Machine3, Duration 12
  [... continues for all jobs ...]

You must analyze each job's operations and create a detailed schedule with start and end times for each operation.'

# Machine Coordinator Agent
role: 'Machine Coordinator'
goal: 'Resolve machine conflicts and optimize machine utilization.'
backstory: 'You are a machine coordination agent responsible for resolving machine conflicts and optimizing machine utilization.'
query: 'Resolve machine conflicts and optimize machine utilization across all machines.

Dataset: abz07
Number of jobs: 20
Number of machines: 15

Job Specifications:
[... job details ...]

You must identify machine conflicts and provide specific solutions with start/end times for each operation.'

# Supervisor Agent
role: 'JSSP Supervisor'
goal: 'Coordinate all agents and provide final JSSP solution with minimum makespan.'
backstory: 'You are the supervisor agent for Job Shop Scheduling Problems. Coordinate with all agents to find the optimal solution.'
query: 'Aggregate schedules from all agents and optimize for minimum makespan.

Dataset: abz07
Number of jobs: 20
Number of machines: 15

Job Specifications:
[... job details ...]

You must provide a final schedule with specific start/end times and calculate the actual makespan.'
\end{lstlisting}

\subsection{Example Output}

\begin{lstlisting}[caption=OpenAI Swarm Output Example]
Job Scheduler Agent Output:
Job Scheduler Analysis:
We've now shared the operation details with the Machine Coordinator to ensure that machine availability is accounted for properly. This coordination will allow us to develop an optimized schedule adhering to both machine and job constraints. 

I will work on calculating a detailed schedule based on optimized machine sequences and provide the resulting makespan. Please hold on. 

---Compute Step---

To begin scheduling, each operation must have its start and end time determined. Here's a step-by-step approach to construct the schedule while managing machine usages: 

1. Identify all the operations and dependencies.
2. Ensure that operations are sequenced both per job and per machine.
3. Mark out machine availability to prevent conflicts by maintaining machine calendars.

### Calculating the Schedule
We will take a sequential approach, placing each operation at the earliest opportunity that satisfies both job precedence and machine availability constraints.

**Job1 Example:**
- **Step 1**: Machine 2, Duration 24: Starts at time 0 and ends at time 24.
- **Step 2**: Machine 3, Duration 12: Starts after Step 1 ends, from time 24 to 36.

### Finalizing Schedule for All Jobs

Following the above step-by-step planning, detailed scheduling for each job's operations will be systematically calculated. This includes preparing a calendar of machine usage:

1. **Machine Conflicts**: Avoiding overlaps by mapping operation times on each machine.
2. **Dependency Fulfillment**: Start the subsequent operation after the previous operation finishes for each job.
3. **Makespan Calculation**: The latest end time recorded for any operation is the makespan.

### Final Makespan: 
**Example:**
- Let's assume preliminary calculations give us a makespan of 1200 time units once all operations and machine schedules are plotted out.

### Final Output Structure:
```plaintext
FINAL MAKESPAN: 1200
STRUCTURED SCHEDULE:
- Job: Job1, Step: 1, Machine: Machine2, Start Time: 0, End Time: 24, Duration: 24
- Job: Job1, Step: 2, Machine: Machine3, Start Time: 24, End Time: 36, Duration: 12
[... continues for all operations ...]
```
\end{lstlisting}

\section{Output Format Requirements}

All frameworks are required to provide output in the following standardized format:

\begin{lstlisting}[caption=Required Output Format]
FINAL MAKESPAN: [integer value]
STRUCTURED SCHEDULE:
- Job: [job_name], Step: [step_number], Machine: [machine_name], Start Time: [start_time], End Time: [end_time], Duration: [duration]
- Job: [job_name], Step: [step_number], Machine: [machine_name], Start Time: [start_time], End Time: [end_time], Duration: [duration]
[... continues for all operations ...]
\end{lstlisting}

\section{Key Differences Between Frameworks}

\begin{table}[h]
\centering
\caption{Framework Comparison}
\begin{tabular}{|l|c|c|c|c|}
\hline
Framework & Agent Structure & Prompt Style & Output Quality & Success Rate \\
\hline
MAPLE & N+1 agents & Task-based & Optimal solutions & 100.0\% \\
AutoGen & 3 agents & System messages & Template responses & 17.8\% \\
CrewAI & 3 agents & Role-based & Minimal output & 66.7\% \\
LangGraph & 3 agents & System prompts & Conceptual & 88.9\% \\
OpenAI Swarm & 3 agents & Detailed roles & Structured & 71.1\% \\
\hline
\end{tabular}
\end{table}

\section{Conclusion}

The prompt setup for each framework demonstrates different approaches to multi-agent coordination for JSSP problems:

\begin{itemize}
    \item \textbf{MAPLE} uses a dynamic N+1 agent structure with individual job agents and a supervisor, achieving optimal solutions with 100\% success rate
    \item \textbf{AutoGen} provides detailed system messages but often generates template responses
    \item \textbf{CrewAI} uses role-based configuration but produces minimal agent outputs
    \item \textbf{LangGraph} employs system prompts and generates conceptual solutions
    \item \textbf{OpenAI Swarm} uses detailed role specifications and produces structured outputs
\end{itemize}

The standardized input format ensures consistent evaluation across all frameworks, while the required output format enables systematic comparison of solution quality and makespan performance.

\end{document}
